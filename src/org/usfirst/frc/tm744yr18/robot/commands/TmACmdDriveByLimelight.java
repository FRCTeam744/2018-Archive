// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc.tm744yr18.robot.commands;

import org.usfirst.frc.tm744yr18.robot.config.TmIpAddrInfoI;
import org.usfirst.frc.tm744yr18.robot.config.TmSdKeysI.SdKeysE;
import org.usfirst.frc.tm744yr18.robot.devices.TmLimelightDev;
import org.usfirst.frc.tm744yr18.robot.helpers.TmDriverStation;
import org.usfirst.frc.tm744yr18.robot.helpers.TmSdMgr;
import org.usfirst.frc.tm744yr18.robot.interfaces.TmCGrpCallbackI;
import org.usfirst.frc.tm744yr18.robot.interfaces.TmToolsI.P;
import org.usfirst.frc.tm744yr18.robot.interfaces.TmToolsI.P.PrtYn;
import org.usfirst.frc.tm744yr18.robot.interfaces.TmToolsI.Tt;
import org.usfirst.frc.tm744yr18.robot.subsystems.TmSsDriveTrain;

import edu.wpi.first.wpilibj.command.Command;

/**
 * naming convention: TmACmd prefix indicates an autonomous command
 * 					  TmCCmd prefix indicates a common (to auton/teleop) command
 * 					  TmTCmd prefix indicates a telelop command
 */
public class TmACmdDriveByLimelight extends Command {

	TmSsDriveTrain ssDrive;
	TmDriverStation m_tds;
//	double m_speed;
	TmCGrpCallbackI m_callbackObj = null;
	boolean m_isOkToRun = true;
	
	TmLimelightDev m_limel;
	double tx, ty, ta;
	private double heading, range;
//	private VisionData visionData;
//	private Gson gson; // = new Gson();
//	UDPReceiver testReceiver; // = new UDPReceiver("169.254.129.8", 5005);
//    private static int udpMsgCount;
//    private static int udpNoMsgAvailCount;
//    private static int udpErrorCount;
//    private static int udpQueryCount; //nbr of times we've checked for a UDP message
//    private static VisionData[] emulatedData;
    private static int emulatedDataIndex;
    private boolean hasReachedCube;


    public TmACmdDriveByLimelight() {
    	this(null, -1);
    }
    public TmACmdDriveByLimelight(double time) {
    	this(null, time); //, time, speed);
    }
    public TmACmdDriveByLimelight(TmCGrpCallbackI callbackObj, double time) {
    	m_tds = TmDriverStation.getInstance();
    	ssDrive = TmSsDriveTrain.getInstance();
    	m_limel = TmLimelightDev.getInstance();
//    	udpMsgCount = 0;
//        udpNoMsgAvailCount = 0;
//        udpErrorCount = 0;
//        udpQueryCount = 0;
//        TmSdMgr.putNumber(SdKeysE.KEY_VISION_UDP_MSG_COUNT, udpMsgCount); //incomingData);
//    	TmSdMgr.putNumber(SdKeysE.KEY_VISION_UDP_NO_MSG_AVAIL_COUNT, udpNoMsgAvailCount);
//    	TmSdMgr.putNumber(SdKeysE.KEY_VISION_UDP_ERROR_COUNT, udpErrorCount);
//        TmSdMgr.putNumber(SdKeysE.KEY_VISION_UDP_QUERY_COUNT, udpQueryCount); //incomingData);

    	requires(ssDrive);
    	if(time >= 0) {
    		setTimeout(time); //scheduler will start the timeout just before calling initialize()
    	}
//    	m_speed = speed;
    	m_callbackObj = callbackObj;
    	
//    	if(Tm744Opts.isInSimulationMode()) {
//    		emulatedData = new VisionData[10];
//    		for(int i=0; i < emulatedData.length; i++) {
//    			emulatedData[i] = new VisionData();
//    			emulatedData[i].heading = 15 - i;
//    			emulatedData[i].range = 45 - i;
//    		}
//    	} else {
//    		emulatedData = null;
//    	}
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	if( m_tds.isEnabledAutonomous() ) {
    		
    	}
    	
//    	if(gson==null) {
//    		gson = new Gson();
////    		if(Tm744Opts.isInSimulationMode()) {
////    			testReceiver = new UDPReceiver("10.7.44.63", 5006); //"169.254.129.8", 5005);
////    		} else {
//////    			testReceiver = new UDPReceiver("10.7.44.13", 5005); //"169.254.129.8", 5005);
//    			testReceiver = new UDPReceiver(IpAddrInfoE.RASPBERRY_PI_UDP.getIpAddr(), 
//    											IpAddrInfoE.RASPBERRY_PI_UDP.getPort());
////    		}
//    	}
    	
    	m_isOkToRun = true;
    	if(m_callbackObj != null) {
    		m_isOkToRun = m_callbackObj.isOkToRunCmd();
    	}
    	
    	hasReachedCube = false;
    	emulatedDataIndex = 0;
    	
    	tx = m_limel.getHorizontalOffsetDegrees();
    	
    	// x=a?b:c; means if(a){x=b;} else {x=c;}
    	P.println(PrtYn.Y, Tt.getClassName(this) + " - initialized - OkToRun?" + (m_isOkToRun ? "Y" : "N"));
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	double minCmd = 0.05;
    	double kP = -0.1;
		double leftVal = 0;
		double rightVal = 0;
    	double distance;
		
    	if(m_isOkToRun) {
    		hasReachedCube = false; //'true' until we have real code....
    		
    		tx = m_limel.getHorizontalOffsetDegrees();
    		ty = m_limel.getVerticalOffsetDegrees();
    		ta = m_limel.getTargetAreaPercent();
    		
    		TmSdMgr.putNumber("DISTANCE || LIMELIGHT", ta); //incomingData);
    		
    		double headingErr = -tx;
    		double steeringAdj = 0.0;
    		if(tx > 1.0) {
    			steeringAdj = kP * headingErr - minCmd;
    		} else {
    			steeringAdj = kP * headingErr + minCmd; 
    		}
    		leftVal += steeringAdj;
    		rightVal -= steeringAdj;
    		double distMult = .2;
    		double multiplier = 1.0;
    		if(ta < 4){
    			leftVal += distMult;
        		rightVal += distMult;
    		}else{
    			leftVal = 0;
    			rightVal = 0;
    		}
    		
    		
    		P.println(PrtYn.Y, "drvByLimelight: isRdy?" + (m_limel.isRdy("verbose")?"Y":"N") + 
    				" tx=" + tx + " left=" + leftVal + " right=" + rightVal);
			TmSsDriveTrain.Driving.tankDriveRawPercentOutput(leftVal, rightVal);

			//    		visionData = gson.fromJson(testReceiver.getPacket(), VisionData.class);
//    		
//			if(visionData==null && Tm744Opts.isInSimulationMode() && emulatedDataIndex < emulatedData.length) {
//				visionData = emulatedData[emulatedDataIndex++];
//			}
//
//    		if(visionData != null) {
//    			heading = visionData.getHeading();
//    			range = visionData.getRange();
//    			System.out.println("drvByVision: hdg=" + visionData.getHeading() + " rng=" + visionData.getRange());
//
//    			double rConst = 1000.0;
//    			double hConst = 100.0;
//
//    			double aRange = range/rConst;
//    			double aHeading = heading/hConst;
//
//    			double lPow = aRange - aHeading;
//    			double rPow = aRange + aHeading;
//    			if(range > 30) {
//    				//            	talonSRX1.set(ControlMode.PercentOutput, lPow);
//    				//              talonSRX2.set(ControlMode.PercentOutput, rPow);
//    				TmSsDriveTrain.Driving.tankDriveRawPercentOutput(lPow, rPow);
//    			} else {
//    				//hasReachedCube = true;
//    			}
//    		}

    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
    	boolean ans = false;
    	if(m_isOkToRun) {
    		if( ( hasReachedCube || ! m_tds.isEnabledAutonomous()) || isTimedOut()) {
    			ans = true;
    			TmSsDriveTrain.Driving.tankDriveRawPercentOutput(0.0, 0.0); //stop the robot
    		} else {
    			ans = false;
    		}
    	} else {
    		ans = true;
    	}
    	return ans;
    }

    // Called once after isFinished returns true
    protected void end() {
    	if( m_tds.isEnabledAutonomous() ) {
    		TmSsDriveTrain.DrvServices.stopAllMotors();
	
    	}
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	if( m_tds.isEnabledAutonomous() ) {
    		TmSsDriveTrain.DrvServices.stopAllMotors();

    	}
    }
    
//	public class VisionData {
//		double heading;
//		double range;
//		
//		public double getHeading() {
//			return heading;
//		}
//		
//		public double getRange() {
//			return range;
//		}
//	}
	
//    class UDPReceiver{
//        DatagramSocket recieveSocket = null;
//        byte[] receiveData = new byte[2048]; 
//        DatagramPacket recievePacket = null;
//    	
//    	/**
//         * Constructor for the UDP receiver. Sets up internal memory structures in prep to start listening for packets.
//         * 
//         * @param listen_to_addr String of the IP address of the co-processor (For example, "10.17.36.8")
//         * @param listen_on_port integer port number to listen on. Often between 5800 and 5810 per FMS whitepaper. Must match whatever port the coprocessor is sending information to.
//         */
//        
//        public UDPReceiver(String listen_from_addr_in, int listen_on_port_in) {
//            try {
//                recieveSocket = new DatagramSocket(listen_on_port_in);
//                recievePacket = new DatagramPacket(receiveData, receiveData.length);
//                recieveSocket.setSoTimeout(10);
//                
//            } catch (IOException e) {
//                System.out.println("Error: Cannot set up UDP reciever socket: " + e.getMessage());
//                recieveSocket = null;
//            }
//
//        }
//        
//        public String getPacket(){ return getPacket(1); }
//        /**
//         * Listens on the UPD connection for a packet. Casts it into a java string and returns it.
//         * Note this method will block while <i> aggressively polling </i> until a full packet is received,
//         * and drop all packets but the most recent. 
//         * @return String of the data acquired from the UDP connection (if any data gotten)
//         */
//        public String getPacket(int retryLimitArg){
//            boolean lastPacket = false;
//            String incomingData = "";
//            int retryLimit = retryLimitArg;
//            
//            if(recieveSocket != null){
//                while(lastPacket == false && (retryLimit-- > 0)){
//                	TmSdMgr.putNumber(SdKeysE.KEY_VISION_UDP_QUERY_COUNT, ++udpQueryCount);
//                    try {
//                        recieveSocket.receive(recievePacket);
//                        incomingData = new String(recievePacket.getData(), 0, recievePacket.getLength());                       
//                        TmSdMgr.putNumber(SdKeysE.KEY_VISION_UDP_MSG_COUNT, ++udpMsgCount); //incomingData);
//                    } catch (java.net.SocketTimeoutException e) {
//                        /* timeout exception - this is OK, just means we don't see new complete packet. */
//                    	TmSdMgr.putNumber(SdKeysE.KEY_VISION_UDP_NO_MSG_AVAIL_COUNT, ++udpNoMsgAvailCount);
//                        if(incomingData.length() != 0){
//                            // We have a packet and there are no more in the recieve queue. Break and return the last packet one.
//                            lastPacket = true; 
//                            //System.out.println(rx_string);
//                        }
//                    } catch (IOException e) {
//                        /* some other error we didn't think about... don't try to listen anymore */
//                    	TmSdMgr.putNumber(SdKeysE.KEY_VISION_UDP_ERROR_COUNT, ++udpErrorCount);
//
//                        System.out.println("Error: Cannot get data from UDP socket: " + e.getMessage());
//                        recieveSocket.close();
//                        recieveSocket = null;
//                    } 
//                }
//            }
//            
//            return incomingData;
//                
//        }
//    }
}
